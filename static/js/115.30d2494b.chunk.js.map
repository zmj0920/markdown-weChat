{"version":3,"sources":["../../markdown-nice/node_modules/codemirror/mode/verilog/verilog.js"],"names":["CodeMirror","defineMode","config","parserConfig","indentUnit","statementIndentUnit","dontAlignCalls","compilerDirectivesUseRegularIndentation","noIndentKeywords","multiLineStrings","hooks","words","str","obj","split","i","length","curPunc","curKeyword","keywords","isOperatorChar","isBracketChar","unsignedNumber","decimalLiteral","binaryLiteral","octLiteral","hexLiteral","realLiteral","closingBracketOrWord","closingBracket","compilerDirectiveRegex","RegExp","compilerDirectiveBeginRegex","compilerDirectiveEndRegex","blockKeywords","openClose","keyword","undefined","statementKeywords","tokenBase","stream","state","style","quote","ch","peek","test","next","eatWhile","cur","current","startsWith","endsWith","keywordClose","substr","eatSpace","withSpace","backUp","tokenize","escaped","end","eat","tokenComment","skipToEnd","match","maybeEnd","Context","indented","column","type","scopekind","align","prev","this","pushContext","col","indent","c","context","popContext","t","isClosing","text","contextClosing","closingKeywords","electricInput","allClosings","closings","j","push","join","buildElectricInputRegEx","startState","basecolumn","compilerDirectiveIndented","startOfLine","token","ctx","sol","indentation","isInsideScopeKind","isClosingAssignment","close","textAfter","Pass","fromHook","firstChar","charAt","closing","possibleClosing","blockCommentStart","blockCommentEnd","lineComment","fold","defineMIME","name","tlvIdentifierStyle","|",">","$","$$","?$","?*","-","/","/-","@","@-","@++","@+=","@+=-","@--","@-=","%+","%-","%",">>","<<","<>","#","^","^^","^!","*","**","\\","\"","tlvScopePrefixChars","?","tlvIndentUnit","tlvIdentMatch","tlvFirstLevelIndentMatch","tlvLineIndentationMatch","tlvCommentMatch","tlvScopeStyle","depth","tlvIndentationStyle","tlvInBlockComment","string","tlvCodeActive","pos","blankline","chPos","bodyString","slice","pop","tlvNextIndent","beginStatement","tlvIdentNext","prefix","mnemonic","hasOwnProperty","eol","mod","__webpack_require__"],"mappings":"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","file":"static/js/115.30d2494b.chunk.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);else // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode(\"verilog\", function (config, parserConfig) {\n    var indentUnit = config.indentUnit,\n        statementIndentUnit = parserConfig.statementIndentUnit || indentUnit,\n        dontAlignCalls = parserConfig.dontAlignCalls,\n        // compilerDirectivesUseRegularIndentation - If set, Compiler directive\n    // indentation follows the same rules as everything else. Otherwise if\n    // false, compiler directives will track their own indentation.\n    // For example, `ifdef nested inside another `ifndef will be indented,\n    // but a `ifdef inside a function block may not be indented.\n    compilerDirectivesUseRegularIndentation = parserConfig.compilerDirectivesUseRegularIndentation,\n        noIndentKeywords = parserConfig.noIndentKeywords || [],\n        multiLineStrings = parserConfig.multiLineStrings,\n        hooks = parserConfig.hooks || {};\n\n    function words(str) {\n      var obj = {},\n          words = str.split(\" \");\n\n      for (var i = 0; i < words.length; ++i) {\n        obj[words[i]] = true;\n      }\n\n      return obj;\n    }\n    /**\n     * Keywords from IEEE 1800-2012\n     */\n\n\n    var keywords = words(\"accept_on alias always always_comb always_ff always_latch and assert assign assume automatic before begin bind \" + \"bins binsof bit break buf bufif0 bufif1 byte case casex casez cell chandle checker class clocking cmos config \" + \"const constraint context continue cover covergroup coverpoint cross deassign default defparam design disable \" + \"dist do edge else end endcase endchecker endclass endclocking endconfig endfunction endgenerate endgroup \" + \"endinterface endmodule endpackage endprimitive endprogram endproperty endspecify endsequence endtable endtask \" + \"enum event eventually expect export extends extern final first_match for force foreach forever fork forkjoin \" + \"function generate genvar global highz0 highz1 if iff ifnone ignore_bins illegal_bins implements implies import \" + \"incdir include initial inout input inside instance int integer interconnect interface intersect join join_any \" + \"join_none large let liblist library local localparam logic longint macromodule matches medium modport module \" + \"nand negedge nettype new nexttime nmos nor noshowcancelled not notif0 notif1 null or output package packed \" + \"parameter pmos posedge primitive priority program property protected pull0 pull1 pulldown pullup \" + \"pulsestyle_ondetect pulsestyle_onevent pure rand randc randcase randsequence rcmos real realtime ref reg \" + \"reject_on release repeat restrict return rnmos rpmos rtran rtranif0 rtranif1 s_always s_eventually s_nexttime \" + \"s_until s_until_with scalared sequence shortint shortreal showcancelled signed small soft solve specify \" + \"specparam static string strong strong0 strong1 struct super supply0 supply1 sync_accept_on sync_reject_on \" + \"table tagged task this throughout time timeprecision timeunit tran tranif0 tranif1 tri tri0 tri1 triand trior \" + \"trireg type typedef union unique unique0 unsigned until until_with untyped use uwire var vectored virtual void \" + \"wait wait_order wand weak weak0 weak1 while wildcard wire with within wor xnor xor\");\n    /** Operators from IEEE 1800-2012\n       unary_operator ::=\n         + | - | ! | ~ | & | ~& | | | ~| | ^ | ~^ | ^~\n       binary_operator ::=\n         + | - | * | / | % | == | != | === | !== | ==? | !=? | && | || | **\n         | < | <= | > | >= | & | | | ^ | ^~ | ~^ | >> | << | >>> | <<<\n         | -> | <->\n       inc_or_dec_operator ::= ++ | --\n       unary_module_path_operator ::=\n         ! | ~ | & | ~& | | | ~| | ^ | ~^ | ^~\n       binary_module_path_operator ::=\n         == | != | && | || | & | | | ^ | ^~ | ~^\n    */\n\n    var isOperatorChar = /[\\+\\-\\*\\/!~&|^%=?:<>]/;\n    var isBracketChar = /[\\[\\]{}()]/;\n    var unsignedNumber = /\\d[0-9_]*/;\n    var decimalLiteral = /\\d*\\s*'s?d\\s*\\d[0-9_]*/i;\n    var binaryLiteral = /\\d*\\s*'s?b\\s*[xz01][xz01_]*/i;\n    var octLiteral = /\\d*\\s*'s?o\\s*[xz0-7][xz0-7_]*/i;\n    var hexLiteral = /\\d*\\s*'s?h\\s*[0-9a-fxz?][0-9a-fxz?_]*/i;\n    var realLiteral = /(\\d[\\d_]*(\\.\\d[\\d_]*)?E-?[\\d_]+)|(\\d[\\d_]*\\.\\d[\\d_]*)/i;\n    var closingBracketOrWord = /^((`?\\w+)|[)}\\]])/;\n    var closingBracket = /[)}\\]]/;\n    var compilerDirectiveRegex = new RegExp(\"^(`(?:ifdef|ifndef|elsif|else|endif|undef|undefineall|define|include|begin_keywords|celldefine|default|\" + \"nettype|end_keywords|endcelldefine|line|nounconnected_drive|pragma|resetall|timescale|unconnected_drive))\\\\b\");\n    var compilerDirectiveBeginRegex = /^(`(?:ifdef|ifndef|elsif|else))\\b/;\n    var compilerDirectiveEndRegex = /^(`(?:elsif|else|endif))\\b/;\n    var curPunc;\n    var curKeyword; // Block openings which are closed by a matching keyword in the form of (\"end\" + keyword)\n    // E.g. \"task\" => \"endtask\"\n\n    var blockKeywords = words(\"case checker class clocking config function generate interface module package \" + \"primitive program property specify sequence table task\"); // Opening/closing pairs\n\n    var openClose = {};\n\n    for (var keyword in blockKeywords) {\n      openClose[keyword] = \"end\" + keyword;\n    }\n\n    openClose[\"begin\"] = \"end\";\n    openClose[\"casex\"] = \"endcase\";\n    openClose[\"casez\"] = \"endcase\";\n    openClose[\"do\"] = \"while\";\n    openClose[\"fork\"] = \"join;join_any;join_none\";\n    openClose[\"covergroup\"] = \"endgroup\";\n    openClose[\"macro_begin\"] = \"macro_end\";\n\n    for (var i in noIndentKeywords) {\n      var keyword = noIndentKeywords[i];\n\n      if (openClose[keyword]) {\n        openClose[keyword] = undefined;\n      }\n    } // Keywords which open statements that are ended with a semi-colon\n\n\n    var statementKeywords = words(\"always always_comb always_ff always_latch assert assign assume else export for foreach forever if import initial repeat while extern typedef\");\n\n    function tokenBase(stream, state) {\n      var ch = stream.peek(),\n          style;\n      if (hooks[ch] && (style = hooks[ch](stream, state)) != false) return style;\n      if (hooks.tokenBase && (style = hooks.tokenBase(stream, state)) != false) return style;\n\n      if (/[,;:\\.]/.test(ch)) {\n        curPunc = stream.next();\n        return null;\n      }\n\n      if (isBracketChar.test(ch)) {\n        curPunc = stream.next();\n        return \"bracket\";\n      } // Macros (tick-defines)\n\n\n      if (ch == '`') {\n        stream.next();\n\n        if (stream.eatWhile(/[\\w\\$_]/)) {\n          var cur = stream.current();\n          curKeyword = cur; // Macros that end in _begin, are start of block and end with _end\n\n          if (cur.startsWith(\"`uvm_\") && cur.endsWith(\"_begin\")) {\n            var keywordClose = curKeyword.substr(0, curKeyword.length - 5) + \"end\";\n            openClose[cur] = keywordClose;\n            curPunc = \"newblock\";\n          } else {\n            stream.eatSpace();\n\n            if (stream.peek() == '(') {\n              // Check if this is a block\n              curPunc = \"newmacro\";\n            }\n\n            var withSpace = stream.current(); // Move the stream back before the spaces\n\n            stream.backUp(withSpace.length - cur.length);\n          }\n\n          return \"def\";\n        } else {\n          return null;\n        }\n      } // System calls\n\n\n      if (ch == '$') {\n        stream.next();\n\n        if (stream.eatWhile(/[\\w\\$_]/)) {\n          return \"meta\";\n        } else {\n          return null;\n        }\n      } // Time literals\n\n\n      if (ch == '#') {\n        stream.next();\n        stream.eatWhile(/[\\d_.]/);\n        return \"def\";\n      } // Event\n\n\n      if (ch == '@') {\n        stream.next();\n        stream.eatWhile(/[@]/);\n        return \"def\";\n      } // Strings\n\n\n      if (ch == '\"') {\n        stream.next();\n        state.tokenize = tokenString(ch);\n        return state.tokenize(stream, state);\n      } // Comments\n\n\n      if (ch == \"/\") {\n        stream.next();\n\n        if (stream.eat(\"*\")) {\n          state.tokenize = tokenComment;\n          return tokenComment(stream, state);\n        }\n\n        if (stream.eat(\"/\")) {\n          stream.skipToEnd();\n          return \"comment\";\n        }\n\n        stream.backUp(1);\n      } // Numeric literals\n\n\n      if (stream.match(realLiteral) || stream.match(decimalLiteral) || stream.match(binaryLiteral) || stream.match(octLiteral) || stream.match(hexLiteral) || stream.match(unsignedNumber) || stream.match(realLiteral)) {\n        return \"number\";\n      } // Operators\n\n\n      if (stream.eatWhile(isOperatorChar)) {\n        curPunc = stream.current();\n        return \"meta\";\n      } // Keywords / plain variables\n\n\n      if (stream.eatWhile(/[\\w\\$_]/)) {\n        var cur = stream.current();\n\n        if (keywords[cur]) {\n          if (openClose[cur]) {\n            curPunc = \"newblock\";\n\n            if (cur === \"fork\") {\n              // Fork can be a statement instead of block in cases of:\n              // \"disable fork;\" and \"wait fork;\" (trailing semicolon)\n              stream.eatSpace();\n\n              if (stream.peek() == ';') {\n                curPunc = \"newstatement\";\n              }\n\n              stream.backUp(stream.current().length - cur.length);\n            }\n          }\n\n          if (statementKeywords[cur]) {\n            curPunc = \"newstatement\";\n          }\n\n          curKeyword = cur;\n          return \"keyword\";\n        }\n\n        return \"variable\";\n      }\n\n      stream.next();\n      return null;\n    }\n\n    function tokenString(quote) {\n      return function (stream, state) {\n        var escaped = false,\n            next,\n            end = false;\n\n        while ((next = stream.next()) != null) {\n          if (next == quote && !escaped) {\n            end = true;\n            break;\n          }\n\n          escaped = !escaped && next == \"\\\\\";\n        }\n\n        if (end || !(escaped || multiLineStrings)) state.tokenize = tokenBase;\n        return \"string\";\n      };\n    }\n\n    function tokenComment(stream, state) {\n      var maybeEnd = false,\n          ch;\n\n      while (ch = stream.next()) {\n        if (ch == \"/\" && maybeEnd) {\n          state.tokenize = tokenBase;\n          break;\n        }\n\n        maybeEnd = ch == \"*\";\n      }\n\n      return \"comment\";\n    }\n\n    function Context(indented, column, type, scopekind, align, prev) {\n      this.indented = indented;\n      this.column = column;\n      this.type = type;\n      this.scopekind = scopekind;\n      this.align = align;\n      this.prev = prev;\n    }\n\n    function pushContext(state, col, type, scopekind) {\n      var indent = state.indented;\n      var c = new Context(indent, col, type, scopekind ? scopekind : \"\", null, state.context);\n      return state.context = c;\n    }\n\n    function popContext(state) {\n      var t = state.context.type;\n\n      if (t == \")\" || t == \"]\" || t == \"}\") {\n        state.indented = state.context.indented;\n      }\n\n      return state.context = state.context.prev;\n    }\n\n    function isClosing(text, contextClosing) {\n      if (text == contextClosing) {\n        return true;\n      } else {\n        // contextClosing may be multiple keywords separated by ;\n        var closingKeywords = contextClosing.split(\";\");\n\n        for (var i in closingKeywords) {\n          if (text == closingKeywords[i]) {\n            return true;\n          }\n        }\n\n        return false;\n      }\n    }\n\n    function isInsideScopeKind(ctx, scopekind) {\n      if (ctx == null) {\n        return false;\n      }\n\n      if (ctx.scopekind === scopekind) {\n        return true;\n      }\n\n      return isInsideScopeKind(ctx.prev, scopekind);\n    }\n\n    function buildElectricInputRegEx() {\n      // Reindentation should occur on any bracket char: {}()[]\n      // or on a match of any of the block closing keywords, at\n      // the end of a line\n      var allClosings = [];\n\n      for (var i in openClose) {\n        if (openClose[i]) {\n          var closings = openClose[i].split(\";\");\n\n          for (var j in closings) {\n            allClosings.push(closings[j]);\n          }\n        }\n      }\n\n      var re = new RegExp(\"[{}()\\\\[\\\\]]|(\" + allClosings.join(\"|\") + \")$\");\n      return re;\n    } // Interface\n\n\n    return {\n      // Regex to force current line to reindent\n      electricInput: buildElectricInputRegEx(),\n      startState: function startState(basecolumn) {\n        var state = {\n          tokenize: null,\n          context: new Context((basecolumn || 0) - indentUnit, 0, \"top\", \"top\", false),\n          indented: 0,\n          compilerDirectiveIndented: 0,\n          startOfLine: true\n        };\n        if (hooks.startState) hooks.startState(state);\n        return state;\n      },\n      token: function token(stream, state) {\n        var ctx = state.context;\n\n        if (stream.sol()) {\n          if (ctx.align == null) ctx.align = false;\n          state.indented = stream.indentation();\n          state.startOfLine = true;\n        }\n\n        if (hooks.token) {\n          // Call hook, with an optional return value of a style to override verilog styling.\n          var style = hooks.token(stream, state);\n\n          if (style !== undefined) {\n            return style;\n          }\n        }\n\n        if (stream.eatSpace()) return null;\n        curPunc = null;\n        curKeyword = null;\n        var style = (state.tokenize || tokenBase)(stream, state);\n\n        if (style == \"comment\" || style == \"meta\" || style == \"variable\") {\n          if ((curPunc === \"=\" || curPunc === \"<=\") && !isInsideScopeKind(ctx, \"assignment\")) {\n            // '<=' could be nonblocking assignment or lessthan-equals (which shouldn't cause indent)\n            //      Search through the context to see if we are already in an assignment.\n            // '=' could be inside port declaration with comma or ')' afterward, or inside for(;;) block.\n            pushContext(state, stream.column() + curPunc.length, \"assignment\", \"assignment\");\n            if (ctx.align == null) ctx.align = true;\n          }\n\n          return style;\n        }\n\n        if (ctx.align == null) ctx.align = true;\n        var isClosingAssignment = ctx.type == \"assignment\" && closingBracket.test(curPunc) && ctx.prev && ctx.prev.type === curPunc;\n\n        if (curPunc == ctx.type || isClosingAssignment) {\n          if (isClosingAssignment) {\n            ctx = popContext(state);\n          }\n\n          ctx = popContext(state);\n\n          if (curPunc == \")\") {\n            // Handle closing macros, assuming they could have a semicolon or begin/end block inside.\n            if (ctx && ctx.type === \"macro\") {\n              ctx = popContext(state);\n\n              while (ctx && (ctx.type == \"statement\" || ctx.type == \"assignment\")) {\n                ctx = popContext(state);\n              }\n            }\n          } else if (curPunc == \"}\") {\n            // Handle closing statements like constraint block: \"foreach () {}\" which\n            // do not have semicolon at end.\n            if (ctx && ctx.type === \"statement\") {\n              while (ctx && ctx.type == \"statement\") {\n                ctx = popContext(state);\n              }\n            }\n          }\n        } else if ((curPunc == \";\" || curPunc == \",\") && (ctx.type == \"statement\" || ctx.type == \"assignment\") || ctx.type && isClosing(curKeyword, ctx.type)) {\n          ctx = popContext(state);\n\n          while (ctx && (ctx.type == \"statement\" || ctx.type == \"assignment\")) {\n            ctx = popContext(state);\n          }\n        } else if (curPunc == \"{\") {\n          pushContext(state, stream.column(), \"}\");\n        } else if (curPunc == \"[\") {\n          pushContext(state, stream.column(), \"]\");\n        } else if (curPunc == \"(\") {\n          pushContext(state, stream.column(), \")\");\n        } else if (ctx && ctx.type == \"endcase\" && curPunc == \":\") {\n          pushContext(state, stream.column(), \"statement\", \"case\");\n        } else if (curPunc == \"newstatement\") {\n          pushContext(state, stream.column(), \"statement\", curKeyword);\n        } else if (curPunc == \"newblock\") {\n          if (curKeyword == \"function\" && ctx && (ctx.type == \"statement\" || ctx.type == \"endgroup\")) {// The 'function' keyword can appear in some other contexts where it actually does not\n            // indicate a function (import/export DPI and covergroup definitions).\n            // Do nothing in this case\n          } else if (curKeyword == \"task\" && ctx && ctx.type == \"statement\") {// Same thing for task\n          } else if (curKeyword == \"class\" && ctx && ctx.type == \"statement\") {// Same thing for class (e.g. typedef)\n          } else {\n            var close = openClose[curKeyword];\n            pushContext(state, stream.column(), close, curKeyword);\n          }\n        } else if (curPunc == \"newmacro\" || curKeyword && curKeyword.match(compilerDirectiveRegex)) {\n          if (curPunc == \"newmacro\") {\n            // Macros (especially if they have parenthesis) potentially have a semicolon\n            // or complete statement/block inside, and should be treated as such.\n            pushContext(state, stream.column(), \"macro\", \"macro\");\n          }\n\n          if (curKeyword.match(compilerDirectiveEndRegex)) {\n            state.compilerDirectiveIndented -= statementIndentUnit;\n          }\n\n          if (curKeyword.match(compilerDirectiveBeginRegex)) {\n            state.compilerDirectiveIndented += statementIndentUnit;\n          }\n        }\n\n        state.startOfLine = false;\n        return style;\n      },\n      indent: function indent(state, textAfter) {\n        if (state.tokenize != tokenBase && state.tokenize != null) return CodeMirror.Pass;\n\n        if (hooks.indent) {\n          var fromHook = hooks.indent(state);\n          if (fromHook >= 0) return fromHook;\n        }\n\n        var ctx = state.context,\n            firstChar = textAfter && textAfter.charAt(0);\n        if (ctx.type == \"statement\" && firstChar == \"}\") ctx = ctx.prev;\n        var closing = false;\n        var possibleClosing = textAfter.match(closingBracketOrWord);\n        if (possibleClosing) closing = isClosing(possibleClosing[0], ctx.type);\n\n        if (!compilerDirectivesUseRegularIndentation && textAfter.match(compilerDirectiveRegex)) {\n          if (textAfter.match(compilerDirectiveEndRegex)) {\n            return state.compilerDirectiveIndented - statementIndentUnit;\n          }\n\n          return state.compilerDirectiveIndented;\n        }\n\n        if (ctx.type == \"statement\") return ctx.indented + (firstChar == \"{\" ? 0 : statementIndentUnit);else if ((closingBracket.test(ctx.type) || ctx.type == \"assignment\") && ctx.align && !dontAlignCalls) return ctx.column + (closing ? 0 : 1);else if (ctx.type == \")\" && !closing) return ctx.indented + statementIndentUnit;else return ctx.indented + (closing ? 0 : indentUnit);\n      },\n      blockCommentStart: \"/*\",\n      blockCommentEnd: \"*/\",\n      lineComment: \"//\",\n      fold: \"indent\"\n    };\n  });\n  CodeMirror.defineMIME(\"text/x-verilog\", {\n    name: \"verilog\"\n  });\n  CodeMirror.defineMIME(\"text/x-systemverilog\", {\n    name: \"verilog\"\n  }); // TL-Verilog mode.\n  // See tl-x.org for language spec.\n  // See the mode in action at makerchip.com.\n  // Contact: steve.hoover@redwoodeda.com\n  // TLV Identifier prefixes.\n  // Note that sign is not treated separately, so \"+/-\" versions of numeric identifiers\n  // are included.\n\n  var tlvIdentifierStyle = {\n    \"|\": \"link\",\n    \">\": \"property\",\n    // Should condition this off for > TLV 1c.\n    \"$\": \"variable\",\n    \"$$\": \"variable\",\n    \"?$\": \"qualifier\",\n    \"?*\": \"qualifier\",\n    \"-\": \"hr\",\n    \"/\": \"property\",\n    \"/-\": \"property\",\n    \"@\": \"variable-3\",\n    \"@-\": \"variable-3\",\n    \"@++\": \"variable-3\",\n    \"@+=\": \"variable-3\",\n    \"@+=-\": \"variable-3\",\n    \"@--\": \"variable-3\",\n    \"@-=\": \"variable-3\",\n    \"%+\": \"tag\",\n    \"%-\": \"tag\",\n    \"%\": \"tag\",\n    \">>\": \"tag\",\n    \"<<\": \"tag\",\n    \"<>\": \"tag\",\n    \"#\": \"tag\",\n    // Need to choose a style for this.\n    \"^\": \"attribute\",\n    \"^^\": \"attribute\",\n    \"^!\": \"attribute\",\n    \"*\": \"variable-2\",\n    \"**\": \"variable-2\",\n    \"\\\\\": \"keyword\",\n    \"\\\"\": \"comment\"\n  }; // Lines starting with these characters define scope (result in indentation).\n\n  var tlvScopePrefixChars = {\n    \"/\": \"beh-hier\",\n    \">\": \"beh-hier\",\n    \"-\": \"phys-hier\",\n    \"|\": \"pipe\",\n    \"?\": \"when\",\n    \"@\": \"stage\",\n    \"\\\\\": \"keyword\"\n  };\n  var tlvIndentUnit = 3;\n  var tlvTrackStatements = false;\n  var tlvIdentMatch = /^([~!@#\\$%\\^&\\*-\\+=\\?\\/\\\\\\|'\"<>]+)([\\d\\w_]*)/; // Matches an identifier.\n  // Note that ':' is excluded, because of it's use in [:].\n\n  var tlvFirstLevelIndentMatch = /^[! ]  /;\n  var tlvLineIndentationMatch = /^[! ] */;\n  var tlvCommentMatch = /^\\/[\\/\\*]/; // Returns a style specific to the scope at the given indentation column.\n  // Type is one of: \"indent\", \"scope-ident\", \"before-scope-ident\".\n\n  function tlvScopeStyle(state, indentation, type) {\n    // Begin scope.\n    var depth = indentation / tlvIndentUnit; // TODO: Pass this in instead.\n\n    return \"tlv-\" + state.tlvIndentationStyle[depth] + \"-\" + type;\n  } // Return true if the next thing in the stream is an identifier with a mnemonic.\n\n\n  function tlvIdentNext(stream) {\n    var match;\n    return (match = stream.match(tlvIdentMatch, false)) && match[2].length > 0;\n  }\n\n  CodeMirror.defineMIME(\"text/x-tlv\", {\n    name: \"verilog\",\n    hooks: {\n      electricInput: false,\n      // Return undefined for verilog tokenizing, or style for TLV token (null not used).\n      // Standard CM styles are used for most formatting, but some TL-Verilog-specific highlighting\n      // can be enabled with the definition of cm-tlv-* styles, including highlighting for:\n      //   - M4 tokens\n      //   - TLV scope indentation\n      //   - Statement delimitation (enabled by tlvTrackStatements)\n      token: function token(stream, state) {\n        var style = undefined;\n        var match; // Return value of pattern matches.\n        // Set highlighting mode based on code region (TLV or SV).\n\n        if (stream.sol() && !state.tlvInBlockComment) {\n          // Process region.\n          if (stream.peek() == '\\\\') {\n            style = \"def\";\n            stream.skipToEnd();\n\n            if (stream.string.match(/\\\\SV/)) {\n              state.tlvCodeActive = false;\n            } else if (stream.string.match(/\\\\TLV/)) {\n              state.tlvCodeActive = true;\n            }\n          } // Correct indentation in the face of a line prefix char.\n\n\n          if (state.tlvCodeActive && stream.pos == 0 && state.indented == 0 && (match = stream.match(tlvLineIndentationMatch, false))) {\n            state.indented = match[0].length;\n          } // Compute indentation state:\n          //   o Auto indentation on next line\n          //   o Indentation scope styles\n\n\n          var indented = state.indented;\n          var depth = indented / tlvIndentUnit;\n\n          if (depth <= state.tlvIndentationStyle.length) {\n            // not deeper than current scope\n            var blankline = stream.string.length == indented;\n            var chPos = depth * tlvIndentUnit;\n\n            if (chPos < stream.string.length) {\n              var bodyString = stream.string.slice(chPos);\n              var ch = bodyString[0];\n\n              if (tlvScopePrefixChars[ch] && (match = bodyString.match(tlvIdentMatch)) && tlvIdentifierStyle[match[1]]) {\n                // This line begins scope.\n                // Next line gets indented one level.\n                indented += tlvIndentUnit; // Style the next level of indentation (except non-region keyword identifiers,\n                //   which are statements themselves)\n\n                if (!(ch == \"\\\\\" && chPos > 0)) {\n                  state.tlvIndentationStyle[depth] = tlvScopePrefixChars[ch];\n\n                  if (tlvTrackStatements) {\n                    state.statementComment = false;\n                  }\n\n                  depth++;\n                }\n              }\n            } // Clear out deeper indentation levels unless line is blank.\n\n\n            if (!blankline) {\n              while (state.tlvIndentationStyle.length > depth) {\n                state.tlvIndentationStyle.pop();\n              }\n            }\n          } // Set next level of indentation.\n\n\n          state.tlvNextIndent = indented;\n        }\n\n        if (state.tlvCodeActive) {\n          // Highlight as TLV.\n          var beginStatement = false;\n\n          if (tlvTrackStatements) {\n            // This starts a statement if the position is at the scope level\n            // and we're not within a statement leading comment.\n            beginStatement = stream.peek() != \" \" && // not a space\n            style === undefined && // not a region identifier\n            !state.tlvInBlockComment && // not in block comment\n            //!stream.match(tlvCommentMatch, false) && // not comment start\n            stream.column() == state.tlvIndentationStyle.length * tlvIndentUnit; // at scope level\n\n            if (beginStatement) {\n              if (state.statementComment) {\n                // statement already started by comment\n                beginStatement = false;\n              }\n\n              state.statementComment = stream.match(tlvCommentMatch, false); // comment start\n            }\n          }\n\n          var match;\n\n          if (style !== undefined) {\n            // Region line.\n            style += \" \" + tlvScopeStyle(state, 0, \"scope-ident\");\n          } else if (stream.pos / tlvIndentUnit < state.tlvIndentationStyle.length && (match = stream.match(stream.sol() ? tlvFirstLevelIndentMatch : /^   /))) {\n            // Indentation\n            style = // make this style distinct from the previous one to prevent\n            // codemirror from combining spans\n            \"tlv-indent-\" + (stream.pos % 2 == 0 ? \"even\" : \"odd\") + // and style it\n            \" \" + tlvScopeStyle(state, stream.pos - tlvIndentUnit, \"indent\"); // Style the line prefix character.\n\n            if (match[0].charAt(0) == \"!\") {\n              style += \" tlv-alert-line-prefix\";\n            } // Place a class before a scope identifier.\n\n\n            if (tlvIdentNext(stream)) {\n              style += \" \" + tlvScopeStyle(state, stream.pos, \"before-scope-ident\");\n            }\n          } else if (state.tlvInBlockComment) {\n            // In a block comment.\n            if (stream.match(/^.*?\\*\\//)) {\n              // Exit block comment.\n              state.tlvInBlockComment = false;\n\n              if (tlvTrackStatements && !stream.eol()) {\n                // Anything after comment is assumed to be real statement content.\n                state.statementComment = false;\n              }\n            } else {\n              stream.skipToEnd();\n            }\n\n            style = \"comment\";\n          } else if ((match = stream.match(tlvCommentMatch)) && !state.tlvInBlockComment) {\n            // Start comment.\n            if (match[0] == \"//\") {\n              // Line comment.\n              stream.skipToEnd();\n            } else {\n              // Block comment.\n              state.tlvInBlockComment = true;\n            }\n\n            style = \"comment\";\n          } else if (match = stream.match(tlvIdentMatch)) {\n            // looks like an identifier (or identifier prefix)\n            var prefix = match[1];\n            var mnemonic = match[2];\n\n            if ( // is identifier prefix\n            tlvIdentifierStyle.hasOwnProperty(prefix) && ( // has mnemonic or we're at the end of the line (maybe it hasn't been typed yet)\n            mnemonic.length > 0 || stream.eol())) {\n              style = tlvIdentifierStyle[prefix];\n\n              if (stream.column() == state.indented) {\n                // Begin scope.\n                style += \" \" + tlvScopeStyle(state, stream.column(), \"scope-ident\");\n              }\n            } else {\n              // Just swallow one character and try again.\n              // This enables subsequent identifier match with preceding symbol character, which\n              //   is legal within a statement.  (E.g., !$reset).  It also enables detection of\n              //   comment start with preceding symbols.\n              stream.backUp(stream.current().length - 1);\n              style = \"tlv-default\";\n            }\n          } else if (stream.match(/^\\t+/)) {\n            // Highlight tabs, which are illegal.\n            style = \"tlv-tab\";\n          } else if (stream.match(/^[\\[\\]{}\\(\\);\\:]+/)) {\n            // [:], (), {}, ;.\n            style = \"meta\";\n          } else if (match = stream.match(/^[mM]4([\\+_])?[\\w\\d_]*/)) {\n            // m4 pre proc\n            style = match[1] == \"+\" ? \"tlv-m4-plus\" : \"tlv-m4\";\n          } else if (stream.match(/^ +/)) {\n            // Skip over spaces.\n            if (stream.eol()) {\n              // Trailing spaces.\n              style = \"error\";\n            } else {\n              // Non-trailing spaces.\n              style = \"tlv-default\";\n            }\n          } else if (stream.match(/^[\\w\\d_]+/)) {\n            // alpha-numeric token.\n            style = \"number\";\n          } else {\n            // Eat the next char w/ no formatting.\n            stream.next();\n            style = \"tlv-default\";\n          }\n\n          if (beginStatement) {\n            style += \" tlv-statement\";\n          }\n        } else {\n          if (stream.match(/^[mM]4([\\w\\d_]*)/)) {\n            // m4 pre proc\n            style = \"tlv-m4\";\n          }\n        }\n\n        return style;\n      },\n      indent: function indent(state) {\n        return state.tlvCodeActive == true ? state.tlvNextIndent : -1;\n      },\n      startState: function startState(state) {\n        state.tlvIndentationStyle = []; // Styles to use for each level of indentation.\n\n        state.tlvCodeActive = true; // True when we're in a TLV region (and at beginning of file).\n\n        state.tlvNextIndent = -1; // The number of spaces to autoindent the next line if tlvCodeActive.\n\n        state.tlvInBlockComment = false; // True inside /**/ comment.\n\n        if (tlvTrackStatements) {\n          state.statementComment = false; // True inside a statement's header comment.\n        }\n      }\n    }\n  });\n});"],"sourceRoot":""}